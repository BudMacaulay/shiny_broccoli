# # # A list of useful functions in my aim to write a more consistant and understandable codebase.

import os
import shutil
import datetime


def possypot(workdir, potcardir):
    # # #
    # # #
    print('possy to potcar is running')

    for subdir, dirs, files in os.walk(str(workdir)):
        for file in files:
            if file.endswith('POSCAR'):
                print(os.path.join(subdir, file))
                f = open(os.path.join(subdir, file))
                liz = []
                for line in f:
                    if len(liz) < 8:
                        liz.append(line)
                    else:
                        # print('first 8 read')
                        break
                with open(subdir + '/POTCAR', 'w') as outfile:
                    for j in liz[5].split():
                        with open(str(potcardir) + j + '/POTCAR') as infile:
                            for line in infile:
                                outfile.write(line)


def pos2inc(workdir, initialincarfile):
    # Need to change the current handling of these fuckers into a damn json file. As of current i'm just finding
    # parameters that are incar required and adding them by hand
    useratoms = 'Li Ni Mn Co O'.split()
    useratoms_mag = '0.0 1.0 1.0 1.0 0.0'.split()
    useratoms_ul = '-1 2 2 2 -1'.split()
    useratoms_uu = '0.00 5.90 3.90 3.32 0.00'.split()
    useratoms_uj = '0.00 0.00 0.00 0.00 0.00'.split()

    useratomstup = tuple(zip(useratoms, useratoms_mag, useratoms_ul, useratoms_uu, useratoms_uj))

    print('currently defined atoms are ' + str(useratoms) + 'if you expect a different species please add it')

    for subdir, dirs, files in os.walk(workdir):
        for file in files:
            if file.endswith('POSCAR'):

                f = open(os.path.join(subdir, file))
                liz = []
                for line in f:
                    if len(liz) < 8:
                        liz.append(line)
                    else:
                        break

                with open(str(initialincarfile)) as infile:
                    inc_1 = 0
                    incar_lofl = [[]]
                    for line in infile:
                        if line == '\n':
                            incar_lofl[inc_1].append('\n')
                            incar_lofl.append([])
                            inc_1 += 1
                        else:
                            incar_lofl[inc_1].append(line)
                    incar_lofl = [x for x in incar_lofl if x != []]
                    incar_lofl = [item for sublist in incar_lofl for item in sublist if
                                  not item.startswith('!')]
                    incar_lofl = [x.strip() for x in incar_lofl]

                    varry = 0
                    while varry < len(incar_lofl):
                        if incar_lofl[varry].startswith('gen'):
                            incar_lofl[varry] = 'general: - !auto generated by BSM on ' + str(datetime.datetime.now())

                        if incar_lofl[varry].startswith('MAGMOM'):
                            print('line ' + str(varry) + 'being updated')
                            comptup = tuple(zip(liz[5].split(), liz[6].split()))
                            incar_lofl[varry] = 'MAGMOM = '
                            for k in comptup:
                                for elem in useratomstup:
                                    if elem[0] == k[0]:
                                        incar_lofl[varry] = incar_lofl[varry] + k[1] + '*' + elem[1] + ' '
                        if incar_lofl[varry].startswith('LDAUL'):
                            print('line ' + str(varry) + 'being updated')
                            incar_lofl[varry] = 'LDAUL = '
                            for k in comptup:
                                for elem in useratomstup:
                                    if elem[0] == k[0]:
                                        incar_lofl[varry] = incar_lofl[varry] + elem[2] + ' '
                        if incar_lofl[varry].startswith('LDAUU'):
                            print('line ' + str(varry) + 'being updated')
                            incar_lofl[varry] = 'LDAUU = '
                            for k in comptup:
                                for elem in useratomstup:
                                    if elem[0] == k[0]:
                                        incar_lofl[varry] = incar_lofl[varry] + elem[3] + ' '
                        if incar_lofl[varry].startswith('LDAUJ'):
                            incar_lofl[varry] = 'LDAUJ = '
                            for k in comptup:
                                for elem in useratomstup:
                                    if elem[0] == k[0]:
                                        incar_lofl[varry] = incar_lofl[varry] + elem[4] + ' '
                        varry += 1
                incar_write = '\n'.join(incar_lofl)
                with open(subdir + '/INCAR', 'w') as outterfile:
                    outterfile.write(incar_write)


def kpointer(workdir, kpointfile):
    for subdir, dirs, files in os.walk(workdir):
        for file in files:
            if file.endswith('POSCAR'):
                shutil.copy2(kpointfile, subdir)


def tabluateitall(workdir):
    import os
    from operator import itemgetter

    import pandas as pd
    from pymatgen import Structure
    from pymatgen.io.vasp.outputs import Outcar
    from pymatgen.io.vasp.outputs import Vasprun

    data = []
    for subdir, dirs, files in os.walk(workdir):
        for file in files:
            if file.endswith('OUTCAR'):
                try:
                    print(subdir.replace(workdir, ''))
                    file_ou = Outcar(subdir + '/OUTCAR')
                    file_pos = Structure.from_file(subdir + '/POSCAR')
                    file_vr = Vasprun(subdir + '/vasprun.xml')

                    # Add things to a list
                    data.append([subdir.replace(workdir, ''), file_pos.composition, file_pos.composition.num_atoms,
                                 file_ou.final_energy, file_ou.final_energy / file_pos.composition.num_atoms,
                                 file_vr.converged])
                except:
                    data.append([subdir.replace(workdir, ''), file_pos.composition, file_pos.composition.num_atoms,
                                 file_ou.final_energy, file_ou.final_energy / file_pos.composition.num_atoms, '!!!',
                                 'FLAG RAISED'])
                    print(
                        'STUPID ERROR - pymatgen doesnt like your outcar or vasprun ??? - Are all jobs complete?')
                    pass

    data = sorted(data, key=itemgetter(0))
    TITLE = ['FOLDER NAME', 'COMPOSITION', 'NO. ATOMS', 'TOTAL ENERGY', 'ENERGY / ATOM', 'CHECK_CONV RESULT', 'FLAGS?']
    data = [[TITLE], data]
    data = [item for sublist in data for item in sublist]
    datadf = pd.DataFrame(data)
    writer = pd.ExcelWriter(workdir + '/TABSFROMRUNS.xlsx')
    datadf.to_excel(writer)
    writer.save()


def slabsets(inputfile, outputdir, plane2cut, vacmin=5, vacmax=15, numberoflayers=6):
    # Plane to cut should be in pymatgen format miller planes - [A, B ,C] otherthan that it basically calls on pymatgen
    # to do the work
    import os.path

    import pymatgen
    from pymatgen.core.structure import Structure
    from pymatgen.core.surface import SlabGenerator
    from pymatgen.io.cif import CifWriter

    slices_string = ''.join(str(e) for e in plane2cut)

    if vacmax == vacmin:
        vac = []
        vac = [vacmin]
    else:
        vac = [None] * 5
        vacrange = ((vacmax - vacmin) / 3)
        vac[0] = 0
        vac[1] = round(vacmin)
        vac[2] = round(vac[1] + vacrange)
        vac[3] = round(vac[2] + vacrange)
        vac[4] = round(vacmax)

    struc = Structure.from_file(inputfile)
    for vacsize in vac:
        slabgen = SlabGenerator(struc, plane2cut, numberoflayers, vacsize, center_slab=True, in_unit_planes=True)
        all_slabs = slabgen.get_slabs()
        CIF = pymatgen.io.cif.CifWriter(all_slabs[0], symprec=1e-4)
        os.makedirs(outputdir + '/' + slices_string + 'vac' + str(vacsize), exist_ok=True)
        CIF.write_file(outputdir + '/' + slices_string + 'vac' + str(vacsize) + '.cif')
        strucs = Structure.from_file(outputdir + '/' + slices_string + 'vac' + str(vacsize) + '.cif')
        strucs.to(filename=(outputdir + '/' + slices_string + 'vac' + str(vacsize) + '/POSCAR'))
